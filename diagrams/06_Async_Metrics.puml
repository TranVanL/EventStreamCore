@startuml Async_Metrics
title Metrics Async Buffering (1ms Thread-Local Buffer)
participant "Thread 1\n(Realtime)" as t1
participant "Thread 2\n(Transactional)" as t2
participant "Thread 3\n(Batch)" as t3
participant "Metrics\nRegistry" as registry
participant "Background\nReporter" as reporter

== Event Processing (Per Thread) ==

par
  t1 -> t1: Process event
  t1 -> t1: local_count++\n(NO LOCK!\nJust write)
  note right of t1: Thread-local\nZero contention

  t2 -> t2: Process event
  t2 -> t2: local_sum += latency\n(NO LOCK!)
  
  t3 -> t3: Process event
  t3 -> t3: local_count++\n(NO LOCK!)
end

note right of t1: 1000 events = 1ms\nat 1M event/sec

== Every 1000 Events (Or 1ms) ==

par
  t1 -> registry: Acquire lock\nFlush all 1000 events
  note right of registry: Only 1 lock!\nnot per event
  
  t2 -> t2: Continue processing\n(no wait for lock!)
  
  t3 -> t3: Continue processing\n(no blocking!)
end

registry -> registry: events_processed += 1000
registry -> registry: latency_sum aggregated
registry -> t1: Release lock

reporter -> registry: Query metrics every 100ms
registry -> reporter: Return snapshots
reporter -> reporter: Compute p50/p99/p99.9

note over t1, reporter: Lock reduction: 246K → 1K ops/sec (95%!)\nCPU improvement: 15% → 2% (87%!)

@enduml
